<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="just ok ......"><title>mysql 查询性能优化二 查询执行的基础 | matrix</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">mysql 查询性能优化二 查询执行的基础</h1><a id="logo" href="/.">matrix</a><p class="description">Simplicity is the ultimate form of sophistication</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">mysql 查询性能优化二 查询执行的基础</h1><div class="post-meta">Aug 1, 2017</div><div class="post-content"><p>当希望 MySQL 能够以更高的性能运行查询时，最好的办法就是弄清楚 MySQL 是如何优化和执行查询的。<br><a id="more"></a><br><img src="https://neoace.github.io/img/mysqloptimize1.png" alt="图 1. 查询执行路径"><br>当我们向 MySQL 发送一个请求的时候， MySQL 执行如下操作：</p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器进行 SQL 解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<h3 id="1-MySQL-客户端-服务器通信协议"><a href="#1-MySQL-客户端-服务器通信协议" class="headerlink" title="1.MySQL 客户端/服务器通信协议"></a>1.MySQL 客户端/服务器通信协议</h3><p>MySQL 客户端和服务器之间的通信心意是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。</p>
<p>限制：一旦一段开始发送消息，另一端要接收完整个消息才能响应它。</p>
<p>客户端用一个独立的数据包将查询传给服务器。<br>服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这也是在必要的时候一定要在查询中加上 LIMIT 限制的原因。</p>
<p>当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是 MySQL 在向客户端推送数据的过程。客户端没法让服务器停下来。</p>
<p>多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。</p>
<p>当使用多数连接 MySQL 的库函数从 MySQL 获取数据时，其结果看起来都像是从 MySQL 服务器获取数据，而实际上都是从这个库函数的缓存获取数据。</p>
<p>查询状态（SHOW FULL PROCESSLIST）：</p>
<ul>
<li>Sleep：线程正在等待客户端发送新的请求。</li>
<li>Query：线程正在执行查询或者正在将结果发送给客户端。</li>
<li>Locked：在 MySQL 服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如 InnoDB 的行锁，并不会体现在线程状态中。</li>
<li>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li>
<li>Copying to tmp table [on disk]：线程正在执行查询，并且将结果集都复制到一个临时表中，这种状态一般要么是在做 GROUP BY 操作，要么是文件排序操作，或者是 UNION 操作。如果这个状态后面还有 on disk 标记，那表示 MySQL 正在将一个内存临时表放到磁盘上。</li>
<li>Sorting result：线程正在对结果集进行排序。</li>
<li>Sending data：这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</li>
</ul>
<h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h3><p>在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。检查是通过对大小写敏感的哈希查找实现的。不匹配则进行下一阶段处理。</p>
<p>命中缓存，那么在返回结果前 MySQL 会检查一次用户权限。如果没有问题，则直接从缓存中拿到结果返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会执行。</p>
<h3 id="3-查询优化处理"><a href="#3-查询优化处理" class="headerlink" title="3.查询优化处理"></a>3.查询优化处理</h3><p>查询的生命周期的下一步是将一个 SQL 转换成一个执行计划，MySQL 再按照这个执行计划和存储引擎进行交互。这包含多个子阶段： 解析 SQL、预处理、优化 SQL 执行计划。</p>
<h4 id="3-1-语法解析器和预处理"><a href="#3-1-语法解析器和预处理" class="headerlink" title="3.1 语法解析器和预处理"></a>3.1 语法解析器和预处理</h4><p>首先，MySQL 通过关键字将 SQL 语句进行解析，并生成一课对应的“解析树”。MySQL 解析器将使用 MySQL 语法规则验证和解析查询。</p>
<p>预处理器则根据一些 MySQL 规则进一步检查解析树是否合法。</p>
<p>下一步预处理器会验证权限。通常很快，除非有非常多的权限配置。</p>
<h4 id="3-2-查询优化器"><a href="#3-2-查询优化器" class="headerlink" title="3.2 查询优化器"></a>3.2 查询优化器</h4><p>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</p>
<p>mysql 通过计算各种执行方式的成本，选择最小成本的查询，可以通过查询当前会话的 Last_query_cost 的值来得知 MySQL 计算的当前查询的成本。</p>
<blockquote>
<p>SELECT SQL_NO_CACHE count(*)<br>FROM film_actor;<br>SHOW STATUS LIKE ‘Last_query_cost’<br>这是根据一系列的统计信息计算得来的：每个表或者索引的页面个数、索引的基数（索引中不同值的数量）、索引和数据行的长度、索引分布情况。</p>
</blockquote>
<p>优化器在评估成本的时候并不考虑任何层面的缓存，它假设读取任何数据都需要一次磁盘 I/O。</p>
<p>导致 MySQL 优化器选择错误的执行计划的原因：</p>
<ul>
<li>统计信息不准确。 MySQL 依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息是准确的，有的偏差可能非常大。</li>
<li>执行计划中的成本估算不等同于实际执行的成本。所以即使统计信息精确，优化器给出的执行计划也可能不是最优的。</li>
<li>MySQL 的最优可能和你想的最优不一样。由此可见，根据执行成本选择执行计划并不是完美的模型。</li>
<li>MySQL 从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。</li>
<li>MySQL 也并不是任何时候都是基于成本的优化。例如全文检索。</li>
<li>MySQL 不会考虑不受其控制的操作的成本。</li>
<li>优化器有时无法去估算所有可能的执行计划。</li>
</ul>
<p>MySQL 查询优化策略分为两种：静态优化和动态优化<br>静态优化：直接对解析树尽心分析，并完成优化。不依赖特别的数值，优化一次一直有效，即使使用不同参数重复执行也不变。可以认为编译时优化。<br>动态优化：和查询的上下文有关，也可能和很多其他因素有关，需要在每次查询时都重新评估，可以认为是“运行时优化”。有时甚至在查询的执行过程中也会重新优化。</p>
<p>MySQL 能够处理的优化类型：</p>
<ul>
<li>重新定义关联表的顺序：数据表的关联并不总是按照在查询中指定的顺序进行。决定关联的顺序是优化器很重要的一部分功能。</li>
<li>将外连接转化成内连接：并不是所有的 OUTER JOIN 语句都必须以外连接的方式执行。</li>
<li>使用等价变换规则：MySQL 可以使用一些等价变换来简化并规范表达式。可以合并一些比较，移除一些恒成立和一些恒不成立的判断等等。</li>
<li>优化 COUNT()、MIN() 和 MAX()：索引和列是否可为空通常可以帮助 MySQL 优化这类表达式。例如：从 B-Tree 索引中取最大值或者最小值；没有任何 WHERE 条件的 COUNT(*) 查询。</li>
<li>预估并转化为常数表达式：当 MySQL 检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。</li>
<li>覆盖索引扫描：当索引中的列包含所有查询中需要使用的列的时候， MySQL 就可以使用索引返回需要的数据，而无须查询对应的数据行。</li>
<li>子查询优化：MySQL 在某些情况下可以将子查询转换成一种效率更高的形式，从而减少多个查询多次对数据进行访问。</li>
<li>提前终止查询：在发现已经满足查询需求的时候，MySQL 总是能够立刻终止查询。例如：LIMIT 子句；再例如，发现一个不成立的条件。</li>
<li>等值传播：如果两个列的值通过等式关联，那么 MySQL 能够把其中一个列的 WHERE 条件传递到另一列上。</li>
<li>列表 IN() 的比较：在很多数据库系统中，IN() 完全等同于多个 OR 条件的子句，因为这两者是完全等价的。而 MySQL 将 IN() 列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是 O(log n) 复杂度；转化成 OR 查询则为 O(n)。<br>不要自以为比优化器更聪明！</li>
</ul>
<h4 id="3-3-数据和索引的统计信息"><a href="#3-3-数据和索引的统计信息" class="headerlink" title="3.3 数据和索引的统计信息"></a>3.3 数据和索引的统计信息</h4><p>不同的存储引擎可能会存储不同的统计信息（也可以按照不同的格式存储统计信息）。</p>
<p>MySQL 查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，包括：每个表或者索引有多少个页面、每个表的每个索引的基数是多少、数据行和索引长度、索引的分布信息等等</p>
<h4 id="3-4-MySQL-如何执行关联查询"><a href="#3-4-MySQL-如何执行关联查询" class="headerlink" title="3.4 MySQL 如何执行关联查询"></a>3.4 MySQL 如何执行关联查询</h4><p>MySQL 认为任何一个查询都是一次“关联” — 并不仅仅是一个查询需要到两个表匹配才叫关联，所以在 MySQL 中，每一个查询，每一个片段（包括子查询，甚至基于单表的 SELECT）都可能使关联。</p>
<p>对于 UNION 查询，MySQL 先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成 UNION 查询。</p>
<p>MySQL 关联执行的策略：MySQL 对任何关联都执行嵌套循环关联操作，即 MySQL 先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，知道找到所有表中匹配的行位置。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL 会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL 返回到上一层次关联表，看是否能够找到更多的匹配记录，以此类推迭代执行。</p>
<p>从本质上来说，MySQL 对所有的类型的查询都以同样的方式运行。例如：子查询先放到一个临时表；UNION 也用类似的临时表。</p>
<h4 id="3-5-执行计划"><a href="#3-5-执行计划" class="headerlink" title="3.5 执行计划"></a>3.5 执行计划</h4><p>MySQL 生成查询的一棵指令树，然后通过存储引擎执行完成这颗指令树并返回结果。最终的执行计划包含了重构查询的全部信息。</p>
<p>如果读某个查询执行 EXPLAIN EXTENDED 后，再执行 SHOW WARNINGS，就可以看到重构出的查询。</p>
<h4 id="3-6-关联查询优化器"><a href="#3-6-关联查询优化器" class="headerlink" title="3.6 关联查询优化器"></a>3.6 关联查询优化器</h4><p>MySQL 优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。关联查询优化器通过评估不同关联顺序时的成本来选择一个代价最小的关联顺序。</p>
<p>如果优化器给出的并不是最优的关联顺序，可以使用 STRAIGHT_JOIN 关键字重新查询，让优化器按照你认为的最优的关联顺序执行。绝大多数时候，优化器做出的选择都比普通人的判断更准确。</p>
<p>关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树。</p>
<p>糟糕的是，如果有超过 n 个表关联，那么需要检查 n 的阶乘种关联关系，称之为所有可能的执行计划的 “搜索空间”，搜索空间的增长非常快。当搜索空间非常大的时候，优化器不可能逐一评估每一种关联顺序的成本，优化器选择使用“贪婪”搜索的方式查找“最优”的关联顺序。</p>
<h4 id="3-7-排序优化"><a href="#3-7-排序优化" class="headerlink" title="3.7 排序优化"></a>3.7 排序优化</h4><p>无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。</p>
<p>如果需要排序的数量小于“排序缓冲区”，MySQL 使用内存进行“快速排序”操作。如果内存不够排序，那么 MySQL 会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。</p>
<p>如果 ORDER BY 子句中的所有列都来自关联的第一个表，那么 MySQL 在关联处理第一个表的时候就进行文件排序。如果是这样，那么在 MySQL 的 EXPLAIN 结果中可以看到 Extra 字段会有 Using filesort。除此之外的所有情况，MySQL 都会先将管理的结果存放到一个临时表中，然后在所有的关联都结束后，再进行文件排序。这时，在 MySQL 的 EXPLAIN 结果的 Extra 字段可以看到 Using temporary; Using filesort。LIMIT 会在排序后应用。</p>
<h3 id="4-查询执行引擎"><a href="#4-查询执行引擎" class="headerlink" title="4.查询执行引擎"></a>4.查询执行引擎</h3><p>查询执行阶段不是那么复杂：MySQL 只是简单地根据执行计划给出的指令逐步执行。</p>
<p>存储引擎接口有着非常丰富的功能，但底层接口却只有几十个，这些接口像“搭积木”一样能够完成查询的大部分操作。</p>
<h3 id="5-返回结果给客户端"><a href="#5-返回结果给客户端" class="headerlink" title="5.返回结果给客户端"></a>5.返回结果给客户端</h3><p>查询执行的最后一个阶段是将结果返回给客户端。</p>
<p>如果查询可以被缓存，那么 MySQL 在这个阶段也会将结果存放到查询缓存中。</p>
<p>MySQL 将结果集返回客户端是一个增量、逐步返回的过程。</p>
</div><div class="tags"><a href="/tags/mysql/">mysql</a></div><div class="post-nav"><a class="next" href="/2017/08/01/mysql-select-optimize/">mysql 查询性能优化一</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://neoace.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/kong/" style="font-size: 15px;">kong</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/head-first/" style="font-size: 15px;">head first</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/mysql-select-optimize2/">mysql 查询性能优化二 查询执行的基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/mysql-select-optimize/">mysql 查询性能优化一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/mysql-index-optimize/">mysql 索引二 高性能索引策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/mysql-index/">mysql 索引一 索引原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/mysql-alert-table-column/">mysql alert table column</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/16/Idea-use-gerrit-plugin/">Idea使用gerrit插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/01/读书学习方法/">读书学习方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/20/mysql学习(一) —— 数据类型的选择/">mysql学习(一) —— 数据类型的选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/08/榴莲/">榴莲成长史</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/Kong安装配置/">Kong安装配置</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">matrix.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>