<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="just ok ......"><title>mysql 索引一 索引原理 | matrix</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">mysql 索引一 索引原理</h1><a id="logo" href="/.">matrix</a><p class="description">Simplicity is the ultimate form of sophistication</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">mysql 索引一 索引原理</h1><div class="post-meta">Jul 31, 2017</div><div class="post-content"><p>1.B+Tree<br>为了解决高效查找某一个范围内的元素的问题，我们引入一个修订后的树：B+树。这也是目前大部分现代数据库索引使用的数据结构。在一个B+树里：</p>
<ul>
<li>只有最底层（叶子节点）才保存信息（相关表的行位置）</li>
<li>其他节点只在搜索中用来指引的正确的节点</li>
</ul>
<p><img src="https://neoace.github.io/img/mysqlindex1.jpeg" alt="图 1. B+Tree 索引结构"><br>找到了M个后续节点，叔总共有N个节点。对指定节点的搜索成本是log(N)，跟上一个树相同。但是当你找到这个节点，你得通过后续节点的连接得到M个后续节点，这需要M次运算。那么这次搜索只消耗了M+log(N)次运算，区别与上一个树所用的N次运算。</p>
<blockquote>
<p>B+树种的 B 不是代表二叉（binary），而是代表平衡（balance），因为 B+树是从最早的平衡二叉树演化而来，但是 B+树不是一个二叉树。</p>
</blockquote>
<p>2.哈希表<br>为了构建一个哈希表，你需要定义：</p>
<ul>
<li>元素的关键字</li>
<li>关键字的哈希函数。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。</li>
<li>关键字比较函数。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素。</li>
</ul>
<p><img src="https://neoace.github.io/img/mysqlindex2.jpeg" alt="图 2. 哈希表"><br>真正的挑战是找到好的哈希函数，让哈希桶里包含非常少的元素。如果有了好的哈希函数，在哈希表里搜索的时间复杂度是 O(1)。</p>
<p>3.InnoDB逻辑存储结构<br>所有数据都被逻辑地存放在一个空间中，称为表空间（tablespace）。表空间由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也被称为块（block）。大致结构如下：</p>
<p><img src="https://neoace.github.io/img/mysqlindex3.jpeg" alt="图 3.  InnoDB 逻辑存储结构"></p>
<ul>
<li><p>3.1 行<br>InnoDB 存储引擎是面向列的（row-oriented），也就是说数据是按行进行存放的。每个页存放的行记录是有硬性定义的，最多允许存放 16KB / 2-200 行的记录，即 7992 行记录。</p>
</li>
<li><p>3.2 索引基础<br>索引类似书籍目录。<br>在MySQL 中，索引是在存储引擎层而不是服务器层实现的。</p>
</li>
<li><p>3.3 索引类型</p>
</li>
<li><p>3.3.1 B-Tree 索引<br>大部分 MySQL 引擎都支持 B-Tree 索引。<br>NDB 集群存储引擎内部实际使用了 T-Tree 结构； InnoDB 则使用的是 B+Tree。<br>MyISAM 使用前缀压缩技术是索引更小；<br>MyISAM 索引通过数据的物理位置引用被索引的行，而 InnoDB 则根据逐渐引用被索引的行。<br>B-Tree 通常以为这所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。如下图：<br><img src="https://neoace.github.io/img/mysqlindex4.jpeg" alt="图 4.  B-Tree索引结构"><br>B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。<br>叶子节点比较特别，他们的指针指向的是被索引的数据，而不是其他的节点页。<br>树的深度和表的大小直接相关。<br>B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。<br>注意：索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。<br>B-Tree 索引有效的查询：</p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配。</li>
<li>匹配最左前缀：只使用索引前面的列。</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分。</li>
<li>匹配范围值：比如只匹配名字</li>
<li>精确匹配某一列并范围匹配另外一列：精确匹配第一列，范围匹配第二列。</li>
<li>只访问索引的查询：查询只需要访问索引，而无须访问数据行。“覆盖索引”。</li>
</ul>
</li>
</ul>
<p>是因为索引树种的节点是有序的，除了查找之外，还可以用于查询中的 ORDER BY 操作。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果 ORDER BY 子句满足前面列出的几种查询类型，则这个索引页可以满足对应的排序需求。<br>B-Tree 索引的限制：</p>
<pre><code>如果不是按照索引的最左列开始查找，则无法使用索引。
不能跳过索引中的列。
如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。
</code></pre><p>再次提醒：索引列的顺序是多么重要，这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。<br>B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<ul>
<li>3.3.2 哈希索引<br>哈希索引（hash index）基于哈希表实现，只有精确匹配查询索引所有列的查询才有效。<br>在 MySQL 中，只有 Memory 引擎显式支持哈希索引。 Memory 引擎是支持 非唯一哈希索引的。<br>如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。<br>哈希索引的限制：<br>  哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。<br>  哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。<br>  哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。<br>  哈希索引只支持等值比较查询，包括 =、 IN()、 &lt;⇒(注意 &lt;&gt; 和 &lt;⇒ 是不同的操作)。<br>  访问哈希索引的数据非常快，除非有很多哈希冲突。哈希冲突时使用链表来解决哈希冲突。<br>  如果哈希冲突很多的话，一些所以维护操作的代价也会很高。冲突越多，代价越大。</li>
</ul>
<p>因为这些限制，哈希索引只适用于某些特定的场合。而一旦适合哈希索引，则它带来的性能提升将非常显著。</p>
<p>除了 Memory 索引外，NDB 集群引擎也支持唯一哈希索引，且在 NDB 集群引擎中作用非常特殊。</p>
<p>InnoDB 引擎有一个特殊的功能叫“自适应哈希索引（adaptive hash index）”。当 InnoDB 注意到某些索引值使用得特别频繁时，它会在内存中基于 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无法控制或者配置，如有必要，可以关闭。</p>
<p>采用这种方式，记住不要使用 SHA1() 和 MD5() 作为哈希函数。因为这两个函数计算出来的哈希值是非常长的字符串，会浪费大量空间，更新时也会更慢。 SHA1() 和 MD5() 设计目标是最大限度消除冲突，但这里并不需要这样高的要求。简单哈希函数的冲突在一个可以接受的范围，同时又能够提供更好的性能。</p>
<p>如果数据表非常大， CRC32() 会出现大量的哈希冲突，则可以实现一个简单的 64 位哈希函数。一个简单的办法可以使用 MD5() 函数返回值的一部分来作为自定义函数。性能稍差，但实现简单。</p>
<ul>
<li>3.3.3 空间数据索引（R-Tree）</li>
</ul>
<p>MyISAM 表支持空间索引，可以用作地理数据存储。空间索引会从所有纬度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。</p>
<p>开源关系数据库系统中对 GIS 的解决方案做得比较好的是 PostgreSQL 的 PostGIS。</p>
<ul>
<li>3.3.4 全文索引</li>
</ul>
<p>全文索引时一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
<p>全文索引更类似于搜索引擎做的事情，而不是简单的 WHERE 条件匹配。</p>
<p>全文索引适用于 MATCH AGAINST 操作，而不是普通的 WHERE 条件查询。</p>
<ul>
<li>3.3.5 分形树索引（fractal tree index）</li>
</ul>
<p>这是一类比较新开发的数据结构，既有 B-Tree 的很多优点，也避免了 B-Tree 的一些缺点。</p>
<p>4.索引的优点<br>索引可以快速定位到表的指定位置；可以用作 ORDER BY 和 GROUP BY 操作；某些查询只使用索引就能够完成全部查询。<br>索引的三个有点：<br>    索引大大减少了服务器需要扫描的数据量。<br>    索引可以帮助服务器避免排序和临时表。<br>    索引可以将随机 I/O 变为顺序 I/O 。</p>
<p>Tapio Lahdenmaki 和 Michael Leach 在书中介绍了如何评价一个索引是否适合某个查询的“三星系统”（three-star system）：<br>    索引将相关的记录放到一起则获得一星；<br>    如果索引中的数据顺序和查找中的排列顺序一致则获得二星；<br>    如果索引中的列包含了查询中需要的全部列则获得“三星”。</p>
<p>索引时最好的解决方案吗？<br>    索引不总是最好的工具。只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这时就需要分区技术。<br>    如果表的数量特别多，可以建立一个元数据信息表，用于查询需要用到的某些特性。例如<br>    对于 TB 级别的数据，定位单条记录的意义不大，所以需要经常会使用块级别元数据技术来替代索引。</p>
</div><div class="tags"><a href="/tags/mysql/">mysql</a></div><div class="post-nav"><a class="pre" href="/2017/07/31/mysql-index-optimize/">mysql 索引二 高性能索引策略</a><a class="next" href="/2017/07/31/mysql-alert-table-column/">mysql alert table column</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://neoace.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/kong/" style="font-size: 15px;">kong</a> <a href="/tags/java8-lamdba/" style="font-size: 15px;">java8, lamdba</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/head-first/" style="font-size: 15px;">head first</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/hanshushi/">java8 lamdba 初探（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/mysql-select-optimize2/">mysql 查询性能优化二 查询执行的基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/mysql-select-optimize/">mysql 查询性能优化一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/mysql-index-optimize/">mysql 索引二 高性能索引策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/mysql-index/">mysql 索引一 索引原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/mysql-alert-table-column/">mysql alert table column</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/16/Idea-use-gerrit-plugin/">Idea使用gerrit插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/01/读书学习方法/">读书学习方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/20/mysql学习(一) —— 数据类型的选择/">mysql学习(一) —— 数据类型的选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/08/榴莲/">榴莲成长史</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">matrix.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>