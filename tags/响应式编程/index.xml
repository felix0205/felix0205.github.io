<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>响应式编程 on Matrix</title>
    <link>https://liufenix.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 响应式编程 on Matrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://liufenix.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reactor介绍</title>
      <link>https://liufenix.github.io/posts/reactor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/1reactor%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liufenix.github.io/posts/reactor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/1reactor%E4%BB%8B%E7%BB%8D/</guid>
      <description>Reactor是什么？ Reactor 框架是 Pivotal 公司开发的，实现了 Reactive Programming 思想，符合 Reactive Streams 规范（Reactive Streams 是由 Netflix、TypeSafe、Pivotal 等公司发起的）的一项开源项目。
Reactor 是完全基于反应式流规范设计和实现的库，是 Spring 5 中反应式编程的基础。
Reactor 官方的描述：
Reactive Streams based projects for backpressure-ready asynchronous message passing.
Reactor 的主要模块 Reactor 框架主要有两个主要的模块：
reactor-core：负责 Reactive Programming 相关的核心 API 的实现 reactor-ipc：负责高性能网络通信的实现，目前是基于 Netty 实现的。 Reactor 的主要类 在 Reactor 中，经常使用的类并不是很多，主要有以下两个：
Mono 实现了 org.reactivestreams.Publisher 接口，代表0到1个元素的发布者。 Flux 同样实现了 org.reactivestreams.Publisher 接口，代表0到N个元素的发表者。 可能会使用到的类
Scheduler 表示背后驱动反应式流的调度器，通常由各种线程池实现。 </description>
    </item>
    
    <item>
      <title>Reactor的历史</title>
      <link>https://liufenix.github.io/posts/reactor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/2reactor%E5%8E%86%E5%8F%B2/</link>
      <pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liufenix.github.io/posts/reactor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/2reactor%E5%8E%86%E5%8F%B2/</guid>
      <description>背景：响应式编程 响应式编程（Reactive Programming）是一种新的编程范式，中文称响应式（或反应式）编程，是一种高性能应用的编程方式。其最早是由微软提出并引入到 .NET 平台中，随后 ES6 也引入了类似的技术。在 Java 平台上，较早采用反应式编程技术的是 Netflix 公司开源的 RxJava 框架。现在大家比较熟知的 Hystrix 就是以 RxJava 为基础开发的。
响应式编程来源于数据流和变化的传播，意味着由底层的执行模型负责通过数据流来自动传播变化。
比如求值一个简单的表达式 c=a+b，当 a 或者 b 的值发生变化时，传统的编程范式需要对 a+b 进行重新计算来得到 c 的值。如果使用反应式编程，当 a 或者 b 的值发生变化时，c 的值会自动更新。
在传统的编程范式中，我们一般通过迭代器（Iterator）模式来遍历一个序列。这种遍历方式是由调用者来控制节奏的，采用的是拉的方式。每次由调用者通过 next()方法来获取序列中的下一个值。使用反应式流时采用的则是推的方式，即常见的发布者-订阅者模式。当发布者有新的数据产生时，这些数据会被推送到订阅者来进行处理。在反应式流上可以添加各种不同的操作来对数据进行处理，形成数据处理链。这个以声明式的方式添加的处理链只在订阅者进行订阅操作时才会真正执行。
响应式编程的基础 响应式编程的基础：
数据流的概念 Observable 类和它的各种操作 通过工厂方法创建静态和动态的Observable 对象 Observable 是事件的源头，Observer 提供了一组简单的接口，并通过订阅事件源来消费 Observable 的事件。Observable 通过 onNext 向 Observer 通知事件的到达，后面可能会跟上 onError 或 onComplete 来表示事件的结束。
反应式编程其实并不神秘，通过与我们熟悉的迭代器模式对比便可了解其基本思想：
event Iterable (pull) Observable (push) retrieve data T next() onNext(T) discover error throws Exception onError(Exception) complete !</description>
    </item>
    
    <item>
      <title>资料收集</title>
      <link>https://liufenix.github.io/posts/reactor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/3%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</link>
      <pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://liufenix.github.io/posts/reactor%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8D/3%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</guid>
      <description>官方资料 Reactor项目官网 Reactor官方文档 Reactor Code Reference Reactor orgnization @ github
Reactor-core仓库 官方提供的学习和练习资料
Lite Rx API Hands-on: 动手练习项目 Head-First Reactive Workshop 社区资料 学习资料 Intro To Reactor Core: 2020
Java反应式框架Reactor中的Mono和Flux: 2020, 写mono和flux最好的文章之一
并发编程之reactor : 2018
八个层面比较 Java 8, RxJava, Reactor: 2018
使用 Reactor 进行反应式编程: 2017，文章有一点早，但内容不错
Reactor模式详解＋源码实现: 2017
Spring Reactor 入门与实践: 2017
Reactor 实例解析: 2016，文章很长，很细致
Reactive programming 一种技术 各自表述</description>
    </item>
    
  </channel>
</rss>
